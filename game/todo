
[x] - shared serilized classes refactor: split into classes Shared|Server|Client
	- [ ] utilize these split classes more

client:
	- [x] refactor
	- [ ] send map json instead of game options


server:
	- [ ] refactor
	- [ ] player paddles should be walls
		-> [ ] add type to walls
	- [x] fix buggy intersection fn: Ball still flies out after a few minutes with high speed..
	- [ ] fix buggy intersection fn: Ball still flies out after a few minutes with rotating wall..
	- [x] why does the server stop sending updates with buggy intersection fn
	- [ ] break down 'Game' class into smaller ones like 'GameLobby' and 'Physics'

server game lobby:
	- [ ] game lobbys can he hidden from matchmaking and require some key to join

misc:
	- [x] frontend: figure out proper way to handle js packages and ts compilation
	- [x] backend: figure out proper way to handle js packages and ts compilation

game options:
	- [ ] client: have a frontend ui to select differnt game options (dummy checkboxes)
	- [ ] client: on confirmation enter matchmaking
	- [~] json map format: create a json map format to define maps

matchmaking:
	- [x] have a basic websocket connection where the client sets up a connection
	- [x] server: send json msg for updates
	- [x] client: parse json msg fn

sockets:
	- [x] server: manage many connections with their corresponding client data
	- [x] implement a basic json format for default communication
	- [x] server: be able to send json for performance uncritical parts
	- [x] client: implement msg type multiplexor
	- [x]: no server side state anymore, msg fully determines action
			{{--server: connection state multiplexor
				-> go to execute specific action when the client is in for example 
				matchmaking or a game--}}
	! [x] update game update coms: split into 3 parts->not needed anymore but still works
		- 1.: new obj notification
		- 2.: obj deactivation
		- 3.: obj update
		-> needs game specicific ID for each object
		-- [x] update classes
		-- [x] update serilization
		-- [x] update deserilization
		-- [x] create objects on frontend
		-- [x] deactive objects on frontend
		-- [x] update objects on frontend
	- [ ] add score and time communication
	! [ ] communicate button press/release from frontend to backend
		-- [ ] client: include account bound unique client ID
		-- [ ] server: map the client id to the correct object
			--- (and set some state with timestamp?
				-> [ ] think of how to handle server side position updates)

game:
	- [x] implement a ball that moves on each frame using babylon-js
	- [x] implement a binary msg format for frame updates
	- [x] server: send binary messages for frame updates
	- [x] client: parse binary msg fn
	- [ ] implement basic pong using babylon-js
	- [ ] make it possible for each client to be 1 or 2 players
	- [ ] client: implement a recconect fn that can be called from the main menu
	- [ ] client: implement ESC to leave the game (to be used to go back to main menu)

game_mechanics:
	- [ ] babylonjs has an exposive barrel asset
	- [ ] babylonjs lava/fire look good
	- [ ] rubber type
	- [ ] magnet type
	- [ ] items (scope creep xd)

game state:
	- [x] backend should be responsible for the balls position
	- [ ] backend: each game should have a unique id
	- [x] backend: manage multiple games at the same time
	- [x] add sidewalls with ball interaction
	- [ ] movable player paddles with ball interaction
	- [ ] point scoring
	- [ ] score board
	- [ ] win conditon (timer/score)
ball.pos.x == Infinity || isNaN(ball.pos.x)
tournament:
	- [ ] TBD

ai:
	- [ ] TBD

cli:
	- [ ] TBD

live chat:
	- [ ] game invitation
	- [ ] tournament notification

DOCS:
match making:
	- first connection of client to server via a websocket

websocket:
	- persistant connection from client joining matchmaking to leaving a game
