[ ]: frontend: 'D' input key is buggy sometimes?
[x]: bug: players can disconnect and join other games without leaving the first leading to a weird server state
	-> [x]: create lobby api needs client_id to verify hes not in game
	-> [x]: create tournamet api needs client_id to verify hes not in game
	-> [x]: verify when joining a lobby
	-> [x]: verify when joing a tournamet
	-> [x]: verify when entering matchmaking
[x]: tournamet backend: when a player leaves pre start there needs to be a player list broadcast
[x]: bug: leave tournamet dosn't fully work?
[x]: bug: if all players disconnect during the game no one can reconnect unless everyone is connected
[x]: craeting a tournament api succeeds even though user is in a running tournamet
	-> check if fixed after leave is fully implemented
[x]: bug: same account 2 sessions leads to buggy lobby
[x]: bug: game frontend displays error msg when a game finishes
[ ]: tournament testing with different user counts and disconnects/leaving players at different points
[ ]: transition to secure connections (API/wss)
[x]: CLI game (will not start before transition to secure connection to not do double work)
[x]: game frontend: limit socket reconnection attempts
	-> [x]: actual counter that when reached cleans up the game and informs the user that he can try to reconnect: max delay 1 min now
[~] - global player count in frontend game lobby scene
	-> [ ] currently only dummy data
[x]: when leaving a tournament before it starts it should remove the player list rendering
[x] - delete empty game lobbies in the backend
[x] - delete empty tournament in the backend
[x]: game frontend : optional fullscreen
[ ]: AI


[x]: bug: player score is not updated in frontend

[x]: {
	1. A creates custom game
	2. A invites B
	3. B accept
	->game start
	4. B dissconnect
	5. B reconnect
	->game server state corruption
	->crash after a bit
	
	1. A creates custom game
	2. A invites B
	3. B accept
	->game start
	4. B dissconnect
	5. B reconnect
	6. B leave
	->crash after longer time
	->looks like 2 games: 1 finishes right away since only 1 player is left
	->the other continues
	
	::: Same thing if A invites B and A does the disconnect/reconnect
	
	1. A creates custom game
	4. B dissconnect
	5. B reconnect
	2. A invites B
	3. B accept
	->game start
	
	->game server seems fine
}





[x] - game engine: handle player leave better:
	[x] - broadcast msg to other players that this player left
	[x] - set leaving player to loose as the next positon
	[x] - potentially end game if only 1 player is left


[ ] - when 'leaving' from the frontend and there is no game request from the server
	if the client is in a game (same from the tournament), like this the client can leave without
	an active connection

[ ] - test leaving a tournamet with many differnt senarios with many differnt player counts
!!![x] - leaving a tournamet: implement this before fixing the tournamet brackets; way to buggy right now
	[x] - case 1: player is currently connected to a lobby: should be handled by the lobby
	[x] - case 1.1: game is running
	[x] - case 1.2: game is not running yet
	[x] - case 1.2: needs testing: not testable with the current frontend since game is automatically joined
	[x] - case 2: player is currently assiged to a lobby but not connected: tell lobby to treat this like case 1
	[x] - case 3: the player is currently waiting for the next match



[x] - server side lobby invite check if the sender is actually in the lobby
	(needed if I want to remove password from lobbies so not just anyone can invite)
[x] - remove password from lobbies (invite system makes that not needed)
	-> [x] - autogenerate passwords for private lobbies and tournament games
[x] - improved invite popup
[x] - game should not need to be disconnected when switching side
	 -> notification when game starts
[x] - server crash when a game finishes while a player left with the engine running
[x] - game server: tournamet needs to use new client participation map
[x] - frontend tournamet cleanup

[~] - game backend: think of what should happen with timeouts in a tournamet lobby

[not sure] - matchmaking bug: connections counting to infinity

[x] - update GameLobby.loaded_player_count on websocket close event

[x] - GameServer: make the class static and not object based


API endpoints:
[x]	- /enter_matchmaking -> takes the player id and map name; returns match id
[x]	- /create_lobby ->  like enter_matchmaking but also takes a password; returns match id
[x]	- /create_tournament -> input playercount, map, password; returns tournament id
[x]	- /reconnect -> input user id; returns potential tournament and match id the user is currently taking part in

[x] - /join_game -> takes password, map_name, lobby_id and user_id and returns ServerError (on success empty)

[x] - frontend: when to call the 'join' api (don't call it on reconnect)
	-> refactor joing a lobby only through api pre game constructor, join_game api should then return the lobby id or an errr like enter_matchmaking

[x] - /game/{game_id}/displaynames; returns the displaynames of the game

websocket endpoints:
	- /game/{game_id} -> opens websocket to connect to a game(lobby), might need password on first connection
	- tournament/{tournament_id} -> opens websocket to trournament, first connection needs password verification


[x]:
	-> [x]: 1. Game server needs to know the display name for each client: add to the join game api call
	-> [x]: 2. and broadcast them to the lobby
	-> [x]: 2.5 what if the client misses the broadcast? -> solved by going through an api instead
	-> [x]: 3. frontend needs to display them
	-> [ ]: would be cool: have display names for the lobby screen while waiting -> later (should be simple tho)

[x]: send tournament upates to frontend

[x]: render tournament state
[x]: render game result
[~]: render tournament result

[x]: backend: game timer
[x]: serilize game timer
[x]: backend: game timer for tournament games: currently does nothing

[x]: implement a way to have a lobby for 2 players on the same keyboard

[x]: tournament system


[x]: backend: engine migration
[x]: frontend: adjust websocket communication

[x]: backend: handle clients that leave the game(during game dosnt matter, but pre game start)
[x]: backend: in the lobby pre game not connected clients need to be timed out so others can join


[x]: serilize player scores

[x]: weird keyinput behaivior(sometimes dosnt work,
		after refreshing might work, then after refreshing it might also break)
	-> also sometimes the ball position gets updated but the player paddle dosn'the
		--> simmilar weird behaivior to key inputs

[ ]: fix game_shared dir

[x]: game server: parse clients

[x]: game server: handle clinet bases

[x] - shared serilized classes refactor: split into classes Shared|Server|Client
	- [x] utilize these split classes more



client:
	- [x] refactor
	- [x] send map json instead of game options


server:
	- [x] refactor
	- [x] player paddles should be walls
		-> [x] add type to walls
	- [x] fix buggy intersection fn: Ball still flies out after a few minutes with high speed..
	- [x] fix buggy intersection fn: Ball still flies out after a few minutes with rotating wall..
		-> made checks so this only effects walls that are currently rotating(walls that can rotate can be hit multiple times in a row)
	- [x] slow balls don't get pushed by rotating walls
	- [x] why does the server stop sending updates with buggy intersection fn
	- [x] break down 'Game' class into smaller ones like 'GameLobby' and 'Physics'

server game lobby:
	- [x] game lobbys can he hidden from matchmaking and require some key to join

misc:
	- [x] frontend: figure out proper way to handle js packages and ts compilation
	- [x] backend: figure out proper way to handle js packages and ts compilation

game options:
	- [x] client: on confirmation enter matchmaking
	- [x] json map format: create a json map format to define maps

matchmaking:
	- [x] have a basic websocket connection where the client sets up a connection
	- [x] server: send json msg for updates
	- [x] client: parse json msg fn

sockets:
	- [x] server: manage many connections with their corresponding client data
	- [x] implement a basic json format for default communication
	- [x] server: be able to send json for performance uncritical parts
	- [x] client: implement msg type multiplexor
	- [x]: no server side state anymore, msg fully determines action
			{{--server: connection state multiplexor
				-> go to execute specific action when the client is in for example 
				matchmaking or a game--}}
	! [x] update game update coms: split into 3 parts->not needed anymore but still works
		- 1.: new obj notification
		- 2.: obj deactivation
		- 3.: obj update
		-> needs game specicific ID for each object
		-- [x] update classes
		-- [x] update serilization
		-- [x] update deserilization
		-- [x] create objects on frontend
		-- [x] deactive objects on frontend
		-- [x] update objects on frontend
	- [x] add score communication
	- [x] add time communication
	! [x] communicate button press/release from frontend to backend
		-- [x] client: include account bound unique client ID
		-- [x] server: map the client id to the correct object
			--- (and set some state with timestamp?
				-> [x] think of how to handle server side position updates)

game:
	- [x] implement a ball that moves on each frame using babylon-js
	- [x] implement a binary msg format for frame updates
	- [x] server: send binary messages for frame updates
	- [x] client: parse binary msg fn
	- [x] implement basic pong using babylon-js
	- [x] make it possible for each client to be 1 or 2 players
	- [x] client: implement a recconect fn that can be called from the main menu
	- [ ] client: implement ESC to leave the game (to be used to go back to main menu)

game_mechanics:
	- [ ] babylonjs has an exposive barrel asset
	- [ ] babylonjs lava/fire look good
	- [ ] rubber type
	- [ ] magnet type
	- [ ] items (scope creep xd)

game state:
	- [x] backend should be responsible for the balls position
	- [x] backend: each game should have a unique id
	- [x] backend: manage multiple games at the same time
	- [x] add sidewalls with ball interaction
	- [x] movable player paddles with ball interaction
	- [x] point scoring
	- [x] score board
	- [x] win conditon (timer[x]/score[x])
tournament:
	- [ ] TBD

ai:
	- [ ] TBD

cli:
	- [ ] TBD

live chat:
	- [x] game invitation
	- [ ] tournament notification

DOCS:
match making:
	- first connection of client to server via a websocket

websocket:
	- persistant connection from client joining matchmaking to leaving a game
