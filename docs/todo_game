[x]: {
	1. A creates custom game
	2. A invites B
	3. B accept
	->game start
	4. B dissconnect
	5. B reconnect
	->game server state corruption
	->crash after a bit
	
	1. A creates custom game
	2. A invites B
	3. B accept
	->game start
	4. B dissconnect
	5. B reconnect
	6. B leave
	->crash after longer time
	->looks like 2 games: 1 finishes right away since only 1 player is left
	->the other continues
	
	::: Same thing if A invites B and A does the disconnect/reconnect
	
	1. A creates custom game
	4. B dissconnect
	5. B reconnect
	2. A invites B
	3. B accept
	->game start
	
	->game server seems fine
}




[0]   placements: [ { id: 1, final_placement: 2 }, { id: 2, final_placement: 1 } ]
[0] }
[0] Tournament: starting round 1
[0] Tournament 1 finished
[0] removing tournament with id:  1
[0] removing lobby  283 : 
[0] {"level":30,"time":1755070370013,"pid":13237,"hostname":"2976a1943b36","reqId":"req-1q","req":{"method":"GET","url":"/game/283","host":"localhost:3000","remoteAddress":"127.0.0.1","remotePort":4
7806},"msg":"incoming request"}
[0] {"level":30,"time":1755070370016,"pid":13237,"hostname":"2976a1943b36","reqId":"req-1r","req":{"method":"POST","url":"/api/leave_tournament","host":"localhost:3000","remoteAddress":"127.0.0.1","
remotePort":47810},"msg":"incoming request"}
[0] {"level":30,"time":1755070370018,"pid":13237,"hostname":"2976a1943b36","reqId":"req-1r","res":{"statusCode":400},"err":{"type":"Error","message":"body must have required property 'lobby_id'","st
ack":"Error: body must have required property 'lobby_id'\n    at defaultSchemaErrorFormatter (/home/frapp/app/core/backend/node_modules/fastify/lib/context.js:92:10)\n    at wrapValidationError (/ho
me/frapp/app/core/backend/node_modules/fastify/lib/validation.js:249:17)\n    at validate (/home/frapp/app/core/backend/node_modules/fastify/lib/validation.js:167:16)\n    at preValidationCallback (
/home/frapp/app/core/backend/node_modules/fastify/lib/handleRequest.js:89:25)\n    at handler (/home/frapp/app/core/backend/node_modules/fastify/lib/handleRequest.js:73:7)\n    at /home/frapp/app/co
re/backend/node_modules/fastify/lib/contentTypeParser.js:214:9\n    at AsyncResource.runInAsyncScope (node:async_hooks:214:14)\n    at done (/home/frapp/app/core/backend/node_modules/fastify/lib/con
tentTypeParser.js:207:14)\n    at Parser.defaultJsonParser [as fn] (/home/frapp/app/core/backend/node_modules/fastify/lib/contentTypeParser.js:312:7)\n    at IncomingMessage.onEnd (/home/frapp/app/c
ore/backend/node_modules/fastify/lib/contentTypeParser.js:296:27)","statusCode":400,"code":"FST_ERR_VALIDATION","validation":[{"instancePath":"","schemaPath":"#/required","keyword":"required","param
s":{"missingProperty":"lobby_id"},"message":"must have required property 'lobby_id'"}],"validationContext":"body"},"msg":"body must have required property 'lobby_id'"}
[0] {"level":30,"time":1755070370019,"pid":13237,"hostname":"2976a1943b36","reqId":"req-1r","res":{"statusCode":400},"responseTime":3.0440969988703728,"msg":"request completed"}
[0] {"level":30,"time":1755070370023,"pid":13237,"hostname":"2976a1943b36","reqId":"req-1s","req":{"method":"POST","url":"/api/leave_tournament","host":"localhost:3000","remoteAddress":"127.0.0.1","
remotePort":47814},"msg":"incoming request"}
[0] {"level":30,"time":1755070370024,"pid":13237,"hostname":"2976a1943b36","reqId":"req-1s","res":{"statusCode":400},"err":{"type":"Error","message":"body must have required property 'lobby_id'","st
ack":"Error: body must have required property 'lobby_id'\n    at defaultSchemaErrorFormatter (/home/frapp/app/core/backend/node_modules/fastify/lib/context.js:92:10)\n    at wrapValidationError (/ho
me/frapp/app/core/backend/node_modules/fastify/lib/validation.js:249:17)\n    at validate (/home/frapp/app/core/backend/node_modules/fastify/lib/validation.js:167:16)\n    at preValidationCallback (
/home/frapp/app/core/backend/node_modules/fastify/lib/handleRequest.js:89:25)\n    at handler (/home/frapp/app/core/backend/node_modules/fastify/lib/handleRequest.js:73:7)\n    at /home/frapp/app/co
re/backend/node_modules/fastify/lib/contentTypeParser.js:214:9\n    at AsyncResource.runInAsyncScope (node:async_hooks:214:14)\n    at done (/home/frapp/app/core/backend/node_modules/fastify/lib/con
tentTypeParser.js:207:14)\n    at Parser.defaultJsonParser [as fn] (/home/frapp/app/core/backend/node_modules/fastify/lib/contentTypeParser.js:312:7)\n    at IncomingMessage.onEnd (/home/frapp/app/c
ore/backend/node_modules/fastify/lib/contentTypeParser.js:296:27)","statusCode":400,"code":"FST_ERR_VALIDATION","validation":[{"instancePath":"","schemaPath":"#/required","keyword":"required","param
s":{"missingProperty":"lobby_id"},"message":"must have required property 'lobby_id'"}],"validationContext":"body"},"msg":"body must have required property 'lobby_id'"}
[0] {"level":30,"time":1755070370024,"pid":13237,"hostname":"2976a1943b36","reqId":"req-1s","res":{"statusCode":400},"responseTime":0.6684649996459484,"msg":"request completed"}
[0] client  1  points:  0
[0] Client  1  lost
[0] ServerWall {
[0]   center: SharedVec2 { x: -10.1, y: 0 },
[0]   normal: SharedVec2 { x: 1, y: 0 },
[0]   length: 10,
[0]   width: 1,
[0]   effects: [],
[0]   obj_id: 2,
[0]   dispose: false,
[0]   _direct: SharedVec2 { x: 0, y: 1 },
[0]   _endpoint1: SharedVec2 { x: -10.1, y: 5 },
[0]   _endpoint2: SharedVec2 { x: -10.1, y: -50 },
[0]   angular_vel: 0,
[0]   next_normal: undefined,
[0]   interp_normal: undefined,
[0]   rotation: 0
[0] }
[0] Finishing game engine..
[0] game update error: TypeError: Cannot read properties of undefined (reading 'players')
[0]     at Tournament._advance_player_to_round (/home/frapp/app/core/backend/src/game/new/Tournament.ts:217:27)
[0]     at Tournament._finish_game_callback (/home/frapp/app/core/backend/src/game/new/Tournament.ts:242:12)
[0]     at GameLobby._game_engine_finish_callback (/home/frapp/app/core/backend/src/game/new/lobby/GameLobby.ts:109:9)
[0]     at GameEngine._finish_game (/home/frapp/app/core/backend/src/game/new/lobby/engine/GameEngine.ts:185:8)
[0]     at GameEngine.update_balls (/home/frapp/app/core/backend/src/game/new/lobby/engine/GameEngine.ts:258:13)
[0]     at GameEngine.update (/home/frapp/app/core/backend/src/game/new/lobby/engine/GameEngine.ts:341:8)
[0]     at Timeout.<anonymous> (/home/frapp/app/core/backend/src/game/new/lobby/engine/GameEngine.ts:358:10)
[0]     at listOnTimeout (node:internal/timers:588:17)
[0]     at process.processTimers (node:internal/timers:523:7)

[x] - game engine: handle player leave better:
	[x] - broadcast msg to other players that this player left
	[x] - set leaving player to loose as the next positon
	[x] - potentially end game if only 1 player is left


[ ] - when 'leaving' from the frontend and there is no game request from the server
	if the client is in a game (same from the tournament), like this the client can leave without
	an active connection


!!![ ] - leaving a tournamet: implement this before fixing the tournamet brackets; way to buggy right now
	[ ] - case 1: player is currently connected to a lobby: should be handled by the lobby
	[x] - case 1.1: game is running
	[x] - case 1.2: game is not running yet
	[ ] - case 1.2: needs testing: not testable with the current frontend since game is automatically joined
	[ ] - case 2: player is currently assiged to a lobby but not connected: tell lobby to treat this like case 1
	[ ] - case 3: the player is currently waiting for the next match

[ ] - craeting a tournament api succeeds even though user is in a running tournamet
	-> check if fixed after leave is fully implemented

[x] - server side lobby invite check if the sender is actually in the lobby
	(needed if I want to remove password from lobbies so not just anyone can invite)
[ ] - remove password from lobbies (invite system makes that not needed)
	-> [ ] - autogenerate passwords for private lobbies and tournament games
[ ] - improved invite popup
[ ] - game should not need to be disconnected when switching side
	 -> notification when game starts
[x] - server crash when a game finishes while a player left with the engine running
[x] - game server: tournamet needs to use new client participation map
[x] - frontend tournamet cleanup

[ ] - game backend: think of what should happen with timeouts in a tournamet lobby

[not sure] - matchmaking bug: connections counting to infinity

[ ] - delete empty lobbies after some time in the backend
[x] - update GameLobby.loaded_player_count on websocket close event

[x] - GameServer: make the class static and not object based


API endpoints:
[x]	- /enter_matchmaking -> takes the player id and map name; returns match id
[x]	- /create_lobby ->  like enter_matchmaking but also takes a password; returns match id
[x]	- /create_tournament -> input playercount, map, password; returns tournament id
[x]	- /reconnect -> input user id; returns potential tournament and match id the user is currently taking part in

[x] - /join_game -> takes password, map_name, lobby_id and user_id and returns ServerError (on success empty)

[x] - frontend: when to call the 'join' api (don't call it on reconnect)
	-> refactor joing a lobby only through api pre game constructor, join_game api should then return the lobby id or an errr like enter_matchmaking

[x] - /game/{game_id}/displaynames; returns the displaynames of the game

websocket endpoints:
	- /game/{game_id} -> opens websocket to connect to a game(lobby), might need password on first connection
	- tournament/{tournament_id} -> opens websocket to trournament, first connection needs password verification


[x]:
	-> [x]: 1. Game server needs to know the display name for each client: add to the join game api call
	-> [x]: 2. and broadcast them to the lobby
	-> [x]: 2.5 what if the client misses the broadcast? -> solved by going through an api instead
	-> [x]: 3. frontend needs to display them
	-> [ ]: would be cool: have display names for the lobby screen while waiting -> later (should be simple tho)

[ ]: send tournament upates to frontend

[~]: render tournament state
[ ]: render game result
[ ]: render tournament result

[x]: backend: game timer
[x]: serilize game timer
[x]: backend: game timer for tournament games: currently does nothing

[x]: implement a way to have a lobby for 2 players on the same keyboard

[x]: tournament system


[x]: backend: engine migration
[x]: frontend: adjust websocket communication

[x]: backend: handle clients that leave the game(during game dosnt matter, but pre game start)
[x]: backend: in the lobby pre game not connected clients need to be timed out so others can join


[x]: serilize player scores

[x]: weird keyinput behaivior(sometimes dosnt work,
		after refreshing might work, then after refreshing it might also break)
	-> also sometimes the ball position gets updated but the player paddle dosn'the
		--> simmilar weird behaivior to key inputs

[ ]: fix game_shared dir

[x]: game server: parse clients

[x]: game server: handle clinet bases

[x] - shared serilized classes refactor: split into classes Shared|Server|Client
	- [x] utilize these split classes more



client:
	- [x] refactor
	- [x] send map json instead of game options


server:
	- [x] refactor
	- [x] player paddles should be walls
		-> [x] add type to walls
	- [x] fix buggy intersection fn: Ball still flies out after a few minutes with high speed..
	- [x] fix buggy intersection fn: Ball still flies out after a few minutes with rotating wall..
		-> made checks so this only effects walls that are currently rotating(walls that can rotate can be hit multiple times in a row)
	- [x] slow balls don't get pushed by rotating walls
	- [x] why does the server stop sending updates with buggy intersection fn
	- [x] break down 'Game' class into smaller ones like 'GameLobby' and 'Physics'

server game lobby:
	- [x] game lobbys can he hidden from matchmaking and require some key to join

misc:
	- [x] frontend: figure out proper way to handle js packages and ts compilation
	- [x] backend: figure out proper way to handle js packages and ts compilation

game options:
	- [x] client: on confirmation enter matchmaking
	- [x] json map format: create a json map format to define maps

matchmaking:
	- [x] have a basic websocket connection where the client sets up a connection
	- [x] server: send json msg for updates
	- [x] client: parse json msg fn

sockets:
	- [x] server: manage many connections with their corresponding client data
	- [x] implement a basic json format for default communication
	- [x] server: be able to send json for performance uncritical parts
	- [x] client: implement msg type multiplexor
	- [x]: no server side state anymore, msg fully determines action
			{{--server: connection state multiplexor
				-> go to execute specific action when the client is in for example 
				matchmaking or a game--}}
	! [x] update game update coms: split into 3 parts->not needed anymore but still works
		- 1.: new obj notification
		- 2.: obj deactivation
		- 3.: obj update
		-> needs game specicific ID for each object
		-- [x] update classes
		-- [x] update serilization
		-- [x] update deserilization
		-- [x] create objects on frontend
		-- [x] deactive objects on frontend
		-- [x] update objects on frontend
	- [x] add score communication
	- [x] add time communication
	! [x] communicate button press/release from frontend to backend
		-- [x] client: include account bound unique client ID
		-- [x] server: map the client id to the correct object
			--- (and set some state with timestamp?
				-> [x] think of how to handle server side position updates)

game:
	- [x] implement a ball that moves on each frame using babylon-js
	- [x] implement a binary msg format for frame updates
	- [x] server: send binary messages for frame updates
	- [x] client: parse binary msg fn
	- [x] implement basic pong using babylon-js
	- [x] make it possible for each client to be 1 or 2 players
	- [x] client: implement a recconect fn that can be called from the main menu
	- [ ] client: implement ESC to leave the game (to be used to go back to main menu)

game_mechanics:
	- [ ] babylonjs has an exposive barrel asset
	- [ ] babylonjs lava/fire look good
	- [ ] rubber type
	- [ ] magnet type
	- [ ] items (scope creep xd)

game state:
	- [x] backend should be responsible for the balls position
	- [x] backend: each game should have a unique id
	- [x] backend: manage multiple games at the same time
	- [x] add sidewalls with ball interaction
	- [x] movable player paddles with ball interaction
	- [x] point scoring
	- [x] score board
	- [x] win conditon (timer[x]/score[x])
tournament:
	- [ ] TBD

ai:
	- [ ] TBD

cli:
	- [ ] TBD

live chat:
	- [x] game invitation
	- [ ] tournament notification

DOCS:
match making:
	- first connection of client to server via a websocket

websocket:
	- persistant connection from client joining matchmaking to leaving a game
