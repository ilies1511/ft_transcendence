

refactor game backend:

[ ] - server crash when a game finishes while a player left with the engine running
[ ] - game server: tournamet needs to use new client participation map
[ ] - Tournament leaving support

[ ] - game backend: think of what should happen with timeouts in a tournamet lobby

[ ] - matchmaking bug: connections counting to infinity

[ ] - delete empty lobbies after some time in the backend
[x] - update GameLobby.loaded_player_count on websocket close event

[x] - GameServer: make the class static and not object based


API endpoints:
[x]	- /enter_matchmaking -> takes the player id and map name; returns match id
[x]	- /create_lobby ->  like enter_matchmaking but also takes a password; returns match id
[x]	- /create_tournament -> input playercount, map, password; returns tournament id
[x]	- /reconnect -> input user id; returns potential tournament and match id the user is currently taking part in

[x] - /join_game -> takes password, map_name, lobby_id and user_id and returns ServerError (on success empty)

[x] - frontend: when to call the 'join' api (don't call it on reconnect)
	-> refactor joing a lobby only through api pre game constructor, join_game api should then return the lobby id or an errr like enter_matchmaking

[x] - /game/{game_id}/displaynames; returns the displaynames of the game

websocket endpoints:
	- /game/{game_id} -> opens websocket to connect to a game(lobby), might need password on first connection
	- tournament/{tournament_id} -> opens websocket to trournament, first connection needs password verification


[x]:
	-> [x]: 1. Game server needs to know the display name for each client: add to the join game api call
	-> [x]: 2. and broadcast them to the lobby
	-> [x]: 2.5 what if the client misses the broadcast? -> solved by going through an api instead
	-> [x]: 3. frontend needs to display them
	-> [ ]: would be cool: have display names for the lobby screen while waiting -> later (should be simple tho)

[ ]: send tournament upates to frontend

[ ]: render tournament state
[ ]: render game result
[ ]: render tournament result

[x]: backend: game timer
[x]: serilize game timer
[x]: backend: game timer for tournament games: currently does nothing

[x]: implement a way to have a lobby for 2 players on the same keyboard

[x]: tournament system


[x]: backend: engine migration
[x]: frontend: adjust websocket communication

[x]: backend: handle clients that leave the game(during game dosnt matter, but pre game start)
[x]: backend: in the lobby pre game not connected clients need to be timed out so others can join


[x]: serilize player scores

[x]: weird keyinput behaivior(sometimes dosnt work,
		after refreshing might work, then after refreshing it might also break)
	-> also sometimes the ball position gets updated but the player paddle dosn'the
		--> simmilar weird behaivior to key inputs

[ ]: fix game_shared dir

[x]: game server: parse clients

[x]: game server: handle clinet bases

[x] - shared serilized classes refactor: split into classes Shared|Server|Client
	- [x] utilize these split classes more



client:
	- [x] refactor
	- [x] send map json instead of game options


server:
	- [x] refactor
	- [x] player paddles should be walls
		-> [x] add type to walls
	- [x] fix buggy intersection fn: Ball still flies out after a few minutes with high speed..
	- [x] fix buggy intersection fn: Ball still flies out after a few minutes with rotating wall..
		-> made checks so this only effects walls that are currently rotating(walls that can rotate can be hit multiple times in a row)
	- [x] slow balls don't get pushed by rotating walls
	- [x] why does the server stop sending updates with buggy intersection fn
	- [x] break down 'Game' class into smaller ones like 'GameLobby' and 'Physics'

server game lobby:
	- [x] game lobbys can he hidden from matchmaking and require some key to join

misc:
	- [x] frontend: figure out proper way to handle js packages and ts compilation
	- [x] backend: figure out proper way to handle js packages and ts compilation

game options:
	- [x] client: on confirmation enter matchmaking
	- [x] json map format: create a json map format to define maps

matchmaking:
	- [x] have a basic websocket connection where the client sets up a connection
	- [x] server: send json msg for updates
	- [x] client: parse json msg fn

sockets:
	- [x] server: manage many connections with their corresponding client data
	- [x] implement a basic json format for default communication
	- [x] server: be able to send json for performance uncritical parts
	- [x] client: implement msg type multiplexor
	- [x]: no server side state anymore, msg fully determines action
			{{--server: connection state multiplexor
				-> go to execute specific action when the client is in for example 
				matchmaking or a game--}}
	! [x] update game update coms: split into 3 parts->not needed anymore but still works
		- 1.: new obj notification
		- 2.: obj deactivation
		- 3.: obj update
		-> needs game specicific ID for each object
		-- [x] update classes
		-- [x] update serilization
		-- [x] update deserilization
		-- [x] create objects on frontend
		-- [x] deactive objects on frontend
		-- [x] update objects on frontend
	- [x] add score communication
	- [x] add time communication
	! [x] communicate button press/release from frontend to backend
		-- [x] client: include account bound unique client ID
		-- [x] server: map the client id to the correct object
			--- (and set some state with timestamp?
				-> [x] think of how to handle server side position updates)

game:
	- [x] implement a ball that moves on each frame using babylon-js
	- [x] implement a binary msg format for frame updates
	- [x] server: send binary messages for frame updates
	- [x] client: parse binary msg fn
	- [x] implement basic pong using babylon-js
	- [x] make it possible for each client to be 1 or 2 players
	- [x] client: implement a recconect fn that can be called from the main menu
	- [ ] client: implement ESC to leave the game (to be used to go back to main menu)

game_mechanics:
	- [ ] babylonjs has an exposive barrel asset
	- [ ] babylonjs lava/fire look good
	- [ ] rubber type
	- [ ] magnet type
	- [ ] items (scope creep xd)

game state:
	- [x] backend should be responsible for the balls position
	- [x] backend: each game should have a unique id
	- [x] backend: manage multiple games at the same time
	- [x] add sidewalls with ball interaction
	- [x] movable player paddles with ball interaction
	- [x] point scoring
	- [x] score board
	- [x] win conditon (timer[x]/score[x])
tournament:
	- [ ] TBD

ai:
	- [ ] TBD

cli:
	- [ ] TBD

live chat:
	- [x] game invitation
	- [ ] tournament notification

DOCS:
match making:
	- first connection of client to server via a websocket

websocket:
	- persistant connection from client joining matchmaking to leaving a game
